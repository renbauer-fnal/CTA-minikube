# @project        The CERN Tape Archive (CTA)
# @copyright      Copyright(C) 2010-2021 CERN
# @license        This program is free software: you can redistribute it and/or modify
#                 it under the terms of the GNU General Public License as published by
#                 the Free Software Foundation, either version 3 of the License, or
#                 (at your option) any later version.
#
#                 This program is distributed in the hope that it will be useful,
#                 but WITHOUT ANY WARRANTY; without even the implied warranty of
#                 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#                 GNU General Public License for more details.
#
#                 You should have received a copy of the GNU General Public License
#                 along with this program.  If not, see <http://www.gnu.org/licenses/>.

=pod

=head1 NAME

tape-verify

read CASTOR tapes and verify consistency

=head1 SYNOPSIS

 tape-verify [options] <VID>

(See tape-verify --help for full list of options with default values.)

=head1 DESCRIPTION

The tape-verify tool allows to read a CASTOR tape and to verify its contents against the stored metadata in the name server.


=head1 OPTIONS

=over 4

See tape-verify --help for a full list of options with default values.

=head1 AUTHOR

German Cancio, CERN <German.Cancio@cern.ch>

=head1 MORE INFORMATION

CASTOR home page http://cern.ch/castor, readtp(1), nslisttape(1), nsls(1)

=cut


#
# Standard Common Application Framework beginning sequence
#
BEGIN {
    # use perl libs in /usr/lib/perl
  unshift(@INC, '/usr/lib/perl');
}

#------------------------------------------------------------
# Application
#------------------------------------------------------------

package tape_verify_vid;

use CAF::Application;
use CAF::Reporter;
use LC::Exception qw (SUCCESS throw_error);
use strict;
use vars qw(@ISA);

@ISA = qw(CAF::Application CAF::Reporter);

#
# Public Methods/Functions for CAF
#

sub app_options() {
  # these options complement the ones defined in CAF::Application
  push(my @array,

       { NAME    => 'server=s',
         HELP    => 'tape server to be used for mounting the tape',
         DEFAULT => undef },

       { NAME    => 'filelist=s',
         HELP    => 'file containing a list of file paths and/or fseqs to be checked on the defined VID',
         DEFAULT => undef},

       { NAME    => 'first=i',
         HELP    => 'check first N files on the tape',
         DEFAULT => undef},

       { NAME    => 'last=i',
         HELP    => 'check last N files on the tape',
         DEFAULT => undef},

       { NAME    => 'random=i',
         HELP    => 'check N random files on the tape',
         DEFAULT => undef},

       { NAME    => 'all',
         HELP    => 'check all files on VID known to the name server',
         DEFAULT => undef},

       { NAME    => 'fulltape',
         HELP    => 'force reading of all segments including those deleted',
         DEFAULT => undef},

       { NAME    => 'tptimeout=i',
         HELP    => 'timeout (seconds) for readtp command to complete',
         DEFAULT => 3600*24 },

       { NAME    => 'nstimeout=i',
         HELP    => 'timeout (seconds) for name server commands (nslisttape) to complete',
         DEFAULT => 3600 },

       { NAME    => 'readtp=s',
	 HELP    => 'path/filename to use for the readtp application',
	 DEFAULT => '/usr/bin/readtp' },

       { NAME    => 'readtpblkid=s',
	 HELP    => 'path/filename to use for the readtpblkid application',
 	 DEFAULT => '/usr/bin/readtpblkid' },

       { NAME    => 'positioning=s',
	 HELP    => 'positioning mechanism to use: "block" for block-id based (using readtpblkid), "fseq" for fseq based (using readtp)',
 	 DEFAULT => 'fseq' },

       { NAME    => 'volumethreshold=i',
	 HELP    => 'maximum volume of data (in GB) to process in seek mode before switching to full scan (as in --fulltape)',
	 DEFAULT => '8000' },

       { NAME    => 'filethreshold=i',
	 HELP    => 'maximum number of files to process in seek mode before switching to full scan (as in --fulltape)',
	 DEFAULT => '5000' },

       { NAME    => 'logdir=s',
	 HELP    => 'directory to use for the tape-verify log files (tape-verify-<VID>.log)',
	 DEFAULT => '/tmp' },

       { NAME    => 'cfgfile=s',
 	 HELP    => 'configuration file for tape-verify defaults.',
	 DEFAULT => '/etc/castor/tape-verify.conf'},

       { NAME    => 'maxretries=i',
 	 HELP    => 'maximum retries to retry reading the tape following errors which are either transient (eg. rtcpd device busy - retry the same segment) or retriable (eg. bad label -> skip to the next segment)',
	 DEFAULT => '10'},

       { NAME    => 'metadata=s',
 	 HELP    => '(segment|only|full). "segment": check segment metadata against tape data; "full": check file and segment metadata against tape data; "only": check only file and segment metadata, no tape read.',
	 DEFAULT => 'segment'},

       { NAME    => 'mdcheck=s',
 	 HELP    => '(warn|error). "warn": report metadata inconsistencies as warnings; "error": report metadata inconsistencies as errors.',
	 DEFAULT => 'warn'},

       { NAME    => 'physmapdir=s',
 	 HELP    => 'directory to use for physical mapping files (used for tape positioning optimisation)',
	 DEFAULT => '/tmp'},

       { NAME    => 'usephysmap=s',
 	 HELP    => 'use physical mapping file if available (for tape positioning optimisation)',
	 DEFAULT => 'yes'},

       { NAME    => 'notracks=f',
 	 HELP    => 'Number of tracks actually written on that tape (for tape positioning optimisation, if --usephysmap=no); accepts fractions to indicate occupancy of last track',
	 DEFAULT => '165'},

       { NAME    => 'totaltracks=i',
 	 HELP    => 'Total number of physical tracks for this media. If not provided, will default to hardcoded defaults for each LTO media type.',
	 DEFAULT => undef},

       { NAME    => 'totalbands=i',
 	 HELP    => 'Number of physical bands for this media.',
	 DEFAULT => 4},

       { NAME    => 'lastblockid=i',
 	 HELP    => 'last block ID on tape. If not specified, approximates it by using name server information (last known file blockID + length in blocks + 50% of flush size)',
	 DEFAULT => undef},

       { NAME    => 'posalgo=s',
 	 HELP    => 'Algorithm for tape positioning. "linear": increasing fseq; "random": random fseq ordering; "scan": simple scan (back+forth); "scan2": two scans (second for overlaps); "sltf": shortest locate time first.',
	 DEFAULT => 'sltf'},

       { NAME    => 'noaction',
	 HELP    => 'dry run: do not launch actual verification.'},

    );

    return \@array;

}



sub _initialize {
  my $self = shift;
  #
  # define application specific data.
  #
  # external version number
  $self->{'VERSION'} = '1.3.3';
  # show setup text
  $self->{'USAGE'} =
    "Usage: tape-verify <VID> [options] [<range>]\n";

  # ensure allowed to run
  if (!$>) {
    $self->error("Sorry, but this program cannot be run as root");
    exit(-1);
  }

  #
  # start initialization of CAF::Application
  #
  unless ($self->SUPER::_initialize(@_)) {
    return undef;
  }

  return $self;
}



my $EC=LC::Exception::Context->new->will_store_all;

# fix umask
umask (022);
# minimal Path
$ENV{"PATH"} = "/bin:/sbin:/usr/bin:/usr/sbin";

# unbuffer STDOUT & STDERR
autoflush STDOUT 1;
autoflush STDERR 1;






package NServerInfo;

use strict;
use vars qw(@ISA $this_app @EXPORT);
use LC::Exception qw (SUCCESS throw_error);
use LC::File qw(file_contents);
use CAF::Object;
use LC::Process ();
use POSIX qw(ceil);
use List::Util 'shuffle';


@ISA=qw(CAF::Object CAF::Reporter);

*this_app = \$main::this_app;


my $NSLISTTAPECMD='/usr/bin/nslisttape --checksum -V';
my $NSLSCMD='/usr/bin/nsls --checksum -l';
my $DATABLOCKSIZE = 256 * 1024; # (data) blocksize is used in the context of approximating the physical tape layout for optimising access ordering

$EC=LC::Exception::Context->new->will_store_all;


#my $EC=LC::Exception::Context->new->will_report_all;


#
# load_ns_info: retrieve file and segment information for a given VID:
#              segment: fseq, size, checksum
#                 file: size, checksum



sub load_ns_info {
    my $self=shift;
    my ($qryout, $err);
    my ($errors,$warnings)=(0,0);
    my $maxtries=10;

    # get nslisttape info
    # for each file, get file size and checksum and compare to nslisttape results,
    # [WARN] if no match

    # nslisttape --checksum -V <vid> format:
    # - 1   1 I05657    6018 0025a49b            104857647 100         adler32 8d81e820 /castor/cern.ch/user/g/gcancio/gwtest-100MBfile/91d8b729-2088-4c28-a8c7-f834511ea501-lxbrb1314
    # note that a castor file name can contain spaces (in the middle or trailing!)!

    my $cmd = $NSLISTTAPECMD." ".$self->{'VID'};

    my $tries = 1;
    while ($tries <= $maxtries) {
      $self->verbose('getting nslisttape list with '.$cmd);
      my $execute_status = LC::Process::execute([ $cmd ],
						timeout => $this_app->option("nstimeout"),
						stdout => \$qryout,
						stderr => \$err
					       );
      my $nslisttape_status= $?;
      if (!defined $execute_status || $nslisttape_status != 0) {
        if ($EC->error) {
	      $self->error($EC->error->format_short);
	      $EC->ignore_error();
	    }
        if (grep (/No such volume or no files found/, $err) ||
            grep (/send2nsd: NS002 - send error : No valid credential found/, $err) ||
            grep (/Timed out/,$err)) {
	      if ($tries >= $maxtries) {
	        $self->verbose("Recurring problems obtaining nslisttape information for ".$self->{'VID'});
	        return [(0,0)];
	      } else {
            # retry as something is fishy in the nslisttape output
	        $self->report("try ".$tries."/".$maxtries.": problems accessing name server: ".$self->{'VID'}.", trying again in 60s");
	        $tries++;
	        sleep (60);
	        next;
	      }
  	    }
	    $self->error($qryout) if ($qryout);
	    $self->error($err) if ($err);
	    $self->error("failed to run $cmd, aborting...");
	    return undef;
      } else {
  	     last;
      }
    } # while (1)

    if ($err) {
      $self->warn("$cmd returned STDERR output: ".$err);
      $warnings++;
    }

    # now read this into $self->{'FILEINFO'} with the following structure:
    # $self->{'INFO_FSEQ'}{<fseq>}{'CHKSUM'}
    #                             {'BLOCKID'}
    #                             {'SIZE'}
    #                             {'COMPRESSION'}
    #                             {'FILENAME'}
    # $self->{'INFO_FNAM'}{<filename>}{'FSEQ'}

    my ($vol,$fseq,$blockid,$size,$compression,$chksum,$fname);
   foreach my $f (split(/\n/,$qryout)) {
      if ($f =~ m%^\S+\s(\S+)\s+(\S+)\s+(\S+)\s+(\S+)\s+(\S+)\s+(\S+)\s+(\S+)\s+(\S+)\s+(\S+)\s+(/castor/.+)$%) {
	# checksum information found
	($vol,$fseq,$blockid,$size,$compression,$chksum,$fname)=($3,$4,$5,$6,$7,$9,$10);
      } elsif ($f =~ m%^\S+\s(\S+)\s+(\S+)\s+(\S+)\s+(\S+)\s+(\S+)\s+(\S+)\s+(\S+)\s+(/castor/.+)$%) {
	# assume no checksum information found
	($vol,$fseq,$blockid,$size,$compression,$fname)=($3,$4,$5,$6,$7,$9);
	$self->verbose("no checksum information found for fseq $fseq - $fname");
	# $warnings++; # this will already be reported as a warning during the validation
      } else {
	# treat unexpected output as warnings and ignore.
      	$self->warn("unexpected nslisttape output, ignoring: $f");
	$warnings++;
	next;
      }
      if ($vol ne $self->{'VID'}) {
	$self->error("volume ID mismatch: requested = ".$self->{'VID'}.", nslisttape gives: $vol");
	return undef;
      }
      if (exists ($self->{'INFO_FSEQ'}{$fseq})) {
	$self->error("duplicated file sequence ID found: $fseq");
	return undef;
      }
      if (exists ($self->{'INFO_FNAM'}{$fname})) {
	$self->warn("duplicated file name found (multiple copy on same tape) : $fname");
	$warnings++;
      }
      # remove leading 0's in the checksum
      if (defined $chksum) {
	$chksum =~ s%^0+(\S+)$%$1%;
      }

      $self->{'INFO_FSEQ'}{$fseq}{'CHKSUM'}=$chksum;
      $self->{'INFO_FSEQ'}{$fseq}{'SIZE'}=$size;
      $self->{'INFO_FSEQ'}{$fseq}{'FILENAME'}=$fname;
      $self->{'INFO_FSEQ'}{$fseq}{'COMPRESSION'}=$compression;
      $self->{'INFO_FSEQ'}{$fseq}{'BLOCKID'}=sprintf("%d",hex($blockid)); # translate from hex to dec
      $self->{'INFO_FNAM'}{$fname}{'FSEQ'}=$fseq;
      $self->{'TOTSIZE'} +=$size;
      $self->{'TOTFILES'} +=1;
    }

    $self->verbose("total files according to name server: " . $self->{'TOTFILES'} . " total size (B): " . $self->{'TOTSIZE'});

    if ($self->{'TOTFILES'} == 0) {
      # inconsistency/error getting name server info - should have returned "No such volume or no files found"
      $self->error("name server query inconsistency or error?: no files found, but no corresponding message received from ns");
      $self->info("$cmd output was:");
      $self->info($qryout);
      return undef;
    }

    #
    # build the model of the physical tape layout (used for efficient positioning algorithms)
    #
    # (XXXXX TODO: move all this into a different method. It has nothing to do with the name server initialisation)
    #
    #
    # two alternatives:
    #  a) a mapping is provided containing the physical wrap and LPOS information for each FSEQ
    #  b) no mapping available, the physical layout is constructed deducing from name server and command line information (last block ID (optional), no wraps (required))
    #


    #
    # read/infer number of physical tracks
    #
    if ($this_app->option("totaltracks")) {
      $self->{'TOTALPHYSTRACKS'} = $this_app->option("totaltracks");
    } else {
      #
      # not defined in config, so deduce it
      # the following is a hack(TM) supposed to be used only during testing.
      #
      if ($self->{'VID'} =~ m%^L7%) {
	$self->{'TOTALPHYSTRACKS'} = 168;
      } elsif (($self->{'VID'} =~ m%^L8%)) {
	$self->{'TOTALPHYSTRACKS'} = 204;
      } elsif (($self->{'VID'} =~ m%^(T|I)%)) {
	$self->{'TOTALPHYSTRACKS'} = 200; ###
      } else {
	$self->error("cannot infer number of physical tracks for this cartridge: " . $self->{'VID'});
	return undef;
      }
    }
    $self->verbose("number of physical tracks: " . $self->{'TOTALPHYSTRACKS'});

    #
    # read number of bands
    #
    $self->{'TOTALBANDS'} = $this_app->option("totalbands");

    #
    # XXXX to be improved: assume end-to-end time is 105s
    #
    $self->{'TOTALSEEKTIME'} = 105;



    if (($this_app->option("usephysmap") eq 'yes') && (-e $this_app->option("physmapdir") . "/" . $self->{'VID'} . ".pmap")) {
      # use map file
      # format of map file:   <fseq1>  <wrap ID> <LPOS> <block id (dec)> separated by (one or more) spaces
      #                       <fseq2>  <wrap ID> <LPOS> <block id (dec)>
      #                       ....
      #                       EOD <wrap ID> <LPOS> <block id (dec)> -> this EOD entry is for signaling the EOD information (end of last segment)
      # lines starting with # will be ignored

      #
      # XXXX to be improved: the number of positions per track is hardcoded below and corresponds to the max(LPOS) observed in LTO.
      # the LPOS unit is not blocks but rather arbitrary as defined by the drive's max LPOS
      # This value shouldn't appear at all (neither hardcoded nor read in) as the positioning is always relative between fseqs.
      # However, the current positioning logic relies on position ID's to start at the beginning of the track rather than to be measured from BOT.

      $self->{'POSPERTRACK'}=171144;


      my $physmapfile = $this_app->option("physmapdir") . "/" . $self->{'VID'} . ".pmap";
      $self->verbose ("using physical map file: " . $physmapfile);
      my $handle;
      unless (open $handle, '<', $physmapfile) {
	$self->error ("cannot open mapping file: ".$physmapfile);
	return undef;
      }
      chomp(my @maplines = <$handle>);
      close $handle;

      my ($wrap,$lpos);
      my $prevfseq=undef;
      foreach my $line (@maplines) {
	# each line contains one entry with (fseq,wrap,lpos,blockid) separated by white spaces
	next if ($line =~ m%^(#|$)%); # ignore lines starting with # (comments) and empty lines
	if ($line =~ m%^(\S+)\s+(\d+)\s+(\d+)\s+(\d+)\s*\S*$%) {
	  ($fseq,$wrap,$lpos,$blockid) = ($1,$2,$3,$4);
	} else {
	  $self->error ("cannot parse line from mapping file ".$physmapfile. ": ");
	  $self->error($line);
	  return undef;
	}

	if (uc($fseq) ne 'EOD') { # EOD is special and only is for the last segment
	  $self->{'INFO_FSEQ'}{$fseq}{'START_TRACK'} = $wrap;
	  $self->{'INFO_FSEQ'}{$fseq}{'START_POS_TRACK'} = ($wrap %2 ? $self->{'POSPERTRACK'} - $lpos : $lpos);
	  if (exists $self->{'INFO_FSEQ'}{$fseq}{'BLOCKID'}) {
	    # do we know of that fseq from the name server? If yes, block ID's should match
	    if ($self->{'INFO_FSEQ'}{$fseq}{'BLOCKID'} != $blockid) {
	      # block ID's do not correspond between map file and name server, abort
	      $self->error("block ID mismatch for fseq $fseq : name server says ". $self->{'INFO_FSEQ'}{$fseq}{'BLOCKID'} . ", map file says " . $blockid);
	      return undef;
	    }
	  } else {
	    # name server doesn't know about this fseq (either because it was deleted or at the end of the tape and transaction wasn't committed)
	    $self->{'INFO_FSEQ'}{$fseq}{'BLOCKID'} = $blockid;
	  }
	}

	# we do not explicitly know the end LPOS/track of the segment. We assume the mapping is complete and thus
	# the end of the previous segment aligns with the beginning of this one.
	# EOD is a special "segment" and comes at the end, indicating the end of the last data segment.
	if (defined $prevfseq) {
	  $self->{'INFO_FSEQ'}{$prevfseq}{'END_TRACK'} = $wrap ;
	  $self->{'INFO_FSEQ'}{$prevfseq}{'END_POS_TRACK'} = ($wrap %2 ? $self->{'POSPERTRACK'} - $lpos + 1: $lpos -1); # make sure previous fseq position ends before this one
	}
	$prevfseq = $fseq ;
      }

    }  else {
      # no mapfile, construct physical layout
      $self->verbose ("not using (or not found) physical map file..");

      my ($lastfseq) = @{$self->get_last_fseq(1)};
      my $totalblocks = $this_app->option("lastblockid");
      if (defined $totalblocks) {
	$totalblocks++ ; # last block ID + 1
      } else {
	# total blocks not provided as option, take it from name server information
	#              assume it's the blockID of the last file on nslisttape + its size + 3 trailer blocks + 16GB worth of uncommitted written space (32GB / 2)
	#              this of course won't work on tapes where the last file has been deleted from ns (the more files deleted at the end without gaps, the more inaccurate)
	$totalblocks = $self->{INFO_FSEQ}{$lastfseq}{'BLOCKID'} + int(($self->{'INFO_FSEQ'}{$lastfseq}{'SIZE'} + 16 * 1000 ** 3) / ($DATABLOCKSIZE)) + 3;
      }

      # different position units per track. In this case, modelled as the average number of blocks per track
      $self->{'POSPERTRACK'}=int($totalblocks / $this_app->option("notracks") + 0.5); # int (x) truncates, int (x + 0.5) rounds up/down

      $self->verbose("total blocks: " . $totalblocks);
      $self->verbose("number of tracks: " . $this_app->option("notracks") . " position units (modelled as average blocks/track): " . $self->{'POSPERTRACK'});

      # the physical mapping algorithm assumes that compression and file
      # size distribution (for header blocks) is averaged out across the
      # tape. This of course is quite an assumption but it is the only
      # way of characterising tapes by just their track count
      # configuration rather than having to examine each tape
      # individually.
      #
      foreach $fseq (sort {$a <=> $b} (keys %{$self->{INFO_FSEQ}})) {
	my $blocks = ceil($self->{'INFO_FSEQ'}{$fseq}{'SIZE'} / ($DATABLOCKSIZE)) + 3 + 3; # calculate the number of blocks including 3 header and 3 trailer blocks
	$self->{'INFO_FSEQ'}{$fseq}{'START_TRACK'} = int ($this_app->option("notracks") * $self->{'INFO_FSEQ'}{$fseq}{'BLOCKID'} / $totalblocks);
	$self->{'INFO_FSEQ'}{$fseq}{'START_POS_TRACK'} = $self->{'INFO_FSEQ'}{$fseq}{'BLOCKID'} - int($self->{'INFO_FSEQ'}{$fseq}{'START_TRACK'} * $totalblocks / $this_app->option("notracks"));
	$self->{'INFO_FSEQ'}{$fseq}{'END_TRACK'} = int ($this_app->option("notracks") * ($self->{'INFO_FSEQ'}{$fseq}{'BLOCKID'} + $blocks) / $totalblocks);
	$self->{'INFO_FSEQ'}{$fseq}{'END_POS_TRACK'} = $self->{'INFO_FSEQ'}{$fseq}{'BLOCKID'} + $blocks - int($self->{'INFO_FSEQ'}{$fseq}{'END_TRACK'} * $totalblocks / $this_app->option("notracks"));
      }
    }


    foreach $fseq (sort {$a <=> $b} (keys %{$self->{INFO_FSEQ}})) {
      $self->debug (1,$self->fseq_info($fseq));
    }

    # all done!
    return [($errors,$warnings)];
}


sub check_file_metadata {
  my ($self,@fseq)=@_;
  my ($qryout, $err);
  my ($errors,$warnings)=(0,0);

  my $shout;
  my $complaints=0;
  if ($this_app->option("mdcheck") eq 'error') {
    $shout='error';
  } else {
    $shout='warn';
  }

  my $tmpfile="/tmp/tape-verify_nsls.".$$;
  my @files;
  foreach (@fseq) {
    push (@files,"'".$self->get_fname_by_fseq($_)."'");
    # quote the files - protect against spaces etc in the file name
  }
  unless (file_contents($tmpfile,join("\n",@files))) {
    $this_app->error("cannot write $tmpfile");
    return undef;
  }


  my $cmd = "/bin/cat $tmpfile | /usr/bin/xargs $NSLSCMD";

  $self->verbose('getting nsls list with '.$cmd);

  my $execute_status = LC::Process::execute([ $cmd ],
					    timeout => $this_app->option("nstimeout"),
					    stdout => \$qryout,
					    stderr => \$err
					   );
  my $nsls_status= $?;
  unlink($tmpfile);
  if (!defined $execute_status) {
    if ($EC->error) {
      $self->error($EC->error->format_short);
      $EC->ignore_error();
    }
    $self->error("failed to run $cmd, aborting...");
    return undef;
  }

  $self->verbose("STDOUT produced:\n$qryout") if ($qryout);
  $self->verbose("STDERR produced:\n$err") if ($err);

  if ($nsls_status != 0) {
    $self->$shout("metadata verification failure - nsls exited with status : $nsls_status");
    # check the STDERR messages.
    foreach my $f (split(/\n/,$err)) {
      if ($f =~ m/No such file or directory/) {
	# means that a file has been renamed or deleted during the time window between
	# nslisstape and nsls. This is unfrequent but can (and does) happen, in particular
	# when checking "fresh" tapes (eg. containing active data).
	# just report a complaint (warning,error) in this case.
	$self->$shout($f);
	$complaints++;
      } else {
	# another error occured, e.g. permission denied or similar.
	# report it back as a complaint and continue the verifying.
	$self->$shout($f);
	$complaints++;
      }
    }
  }


  # now iterate over the files (or fseqs) and obtain the file checksum, and compare it to the segment checksum
  # nsls -l --checksum <file> format:
  # mrw-r--r--   1 gcancio  c3                104857647 Nov 11  2009 AD 8d81e820 /castor/cern.ch/user/g/gcancio/gwtest-100MBfile/91d8b729-2088-4c28-a8c7-f834511ea501-lxbrb1314

  my ($size,$chksum,$fname);
  foreach my $f (split(/\n/,$qryout)) {
    if ($f =~ m%^\S+\s+\S+\s+\S+\s+\S+\s+(\S+)\s+\S+\s+\S+\s+\S+\s+\S+\s+(\S+)\s+(/castor/.+)$%) {
      # checksum information found
      ($size,$chksum,$fname)=($1,$2,$3);
    } elsif ($f =~ m%^\S+\s+\S+\s+\S+\s+\S+\s+(\S+)\s+\S+\s+\S+\s+\S+\s+\s+(/castor/.+)$%) {
      # assume no checksum information found
      ($size,$chksum,$fname)=($1,undef,$2);
      $self->verbose("no file-level checksum information found for file $fname");
    } else {
      $self->error("unexpected nsls output: $f");
      return undef;
    }
    my $fseq = $self->get_fseq_by_fname($fname);
    unless (defined $fseq) {
      $self->error("cannot get fseq for file name: $fname");
      return undef;
    }
    my ($seg_chksum,$seg_size) = @{$self->get_checksum_size_by_fseq($fseq)};
    if ($seg_size != $size) {
      # clear inconsistency - can be of transitory nature for freshly migrated files
      $self->$shout("name server inconsistency for fseq $fseq - file $fname: segment size is $seg_size, file size is $size");
      $complaints++;
    }
    if (defined $seg_chksum && ! defined $chksum) {
      # this is not an error as several protocols (eg RFIO non-streaming, gridftp) do not
      # generate file-level checksums.
      $self->verbose("file checksum missing for fseq $fseq - file $fname: segment checksum is $seg_chksum");
    } elsif (!defined $seg_chksum && defined $chksum) {
      # this should never happen for migrated files
      $self->$shout("name server inconsistency for fseq $fseq - file $fname: segment checksum is undefined, file checksum is $chksum");
      $complaints++;
    } elsif (defined $seg_chksum && defined $chksum && $seg_chksum ne $chksum) {
      # another clear inconsistency - can be of transitory nature for freshly migrated files
      $self->$shout("name server inconsistency for fseq $fseq - file $fname: segment checksum is $seg_chksum, file checksum is $chksum");
      $complaints++;
    }
  }
  if ($this_app->option("mdcheck") eq "error") {
    $errors += $complaints;
  } else {
    $warnings += $complaints;
  }
  return [($errors,$warnings)];
}




sub get_checksum_size_by_fseq {
  my ($self,$fseq)=@_;

  if (exists ($self->{'INFO_FSEQ'}{$fseq})) {
    return [$self->{'INFO_FSEQ'}{$fseq}{'CHKSUM'},$self->{'INFO_FSEQ'}{$fseq}{'SIZE'}];
  } else {
    $self->error("fseq $fseq not found in ns metadata");
    return undef;
  }
}

# return the first $count fseq's. If $count > total number of fseqs, return all fseqs
sub get_first_fseq {
  my ($self,$count)=@_;

  if ($count > scalar (keys %{$self->{'INFO_FSEQ'}})) {
    return $self->get_list_fseq();
  }
  # numeric sort
  return [(sort {$a <=> $b} (keys %{$self->{'INFO_FSEQ'}}))[0..$count-1]];
}

# return the last $count fseq's. If $count > total number of fseqs, return all fseqs
sub get_last_fseq {
  my ($self,$count)=@_;

  if ($count > scalar (keys %{$self->{'INFO_FSEQ'}})) {
    return $self->get_list_fseq();
  }
  return [(sort {$a <=> $b} (keys %{$self->{'INFO_FSEQ'}}))[$self->{'TOTFILES'}-$count..$self->{'TOTFILES'}-1]];
}


# return random $count fseq's. If $count > total number of fseqs, return all fseqs
sub get_random_fseq {
  my ($self,$count)=@_;

  my $i;
  my @fseq=();
  if ($count > scalar (keys %{$self->{'INFO_FSEQ'}})) {
    return $self->get_list_fseq();
  }

  for ($i=1;$i<=$count;$i++) {
    my $pos=int(rand($self->{'TOTFILES'})+1);
    push(@fseq,(keys %{$self->{'INFO_FSEQ'}})[$pos]);
  }
  return [sort {$a <=> $b} @fseq];
}


sub get_list_fseq {
  my $self=shift;
  return [(sort {$a <=> $b} (keys %{$self->{'INFO_FSEQ'}}))];
}


sub get_list_fnames {
  my $self=shift;
  return [(sort (keys %{$self->{'INFO_FNAM'}}))];
}


sub get_fname_by_fseq {
  my ($self,$fseq)=@_;
  unless (exists $self->{'INFO_FSEQ'}{$fseq}) {
    $self->error("fseq $fseq is not defined for VID ".$self->{'VID'});
    return undef;
  }
  return $self->{'INFO_FSEQ'}{$fseq}{'FILENAME'};
}

sub get_fseq_by_fname {
  my ($self,$fname)=@_;
  unless (exists $self->{'INFO_FNAM'}{$fname}) {
    $self->error("file name $fname is not defined for VID ".$self->{'VID'});
    return undef;
  }
  return $self->{'INFO_FNAM'}{$fname}{'FSEQ'};
}

sub get_compression_by_fseq {
  my ($self,$fseq)=@_;

  if (exists ($self->{'INFO_FSEQ'}{$fseq})) {
    return $self->{'INFO_FSEQ'}{$fseq}{'COMPRESSION'};
  } else {
    $self->error("fseq $fseq not found in ns metadata");
    return undef;
  }
}

sub get_blockid_by_fseq {
  my ($self,$fseq)=@_;

  if ($fseq == 0) {return 0}; # special case for modelling BOT

  if (exists ($self->{'INFO_FSEQ'}{$fseq})) {
    return $self->{'INFO_FSEQ'}{$fseq}{'BLOCKID'};
  } else {
    $self->error("fseq $fseq not found in ns metadata");
    return undef;
  }
}

sub get_start_track_by_fseq {
  my ($self,$fseq)=@_;

  if ($fseq == 0) {return 0}; # special case for modelling BOT

  if (exists ($self->{'INFO_FSEQ'}{$fseq})) {
    return $self->{'INFO_FSEQ'}{$fseq}{'START_TRACK'};
  } else {
    $self->error("fseq $fseq not found in ns metadata");
    return undef;
  }
}

sub get_end_track_by_fseq {
  my ($self,$fseq)=@_;

  if ($fseq == 0) {return 0}; # special case for modelling BOT

  if (exists ($self->{'INFO_FSEQ'}{$fseq})) {
    return $self->{'INFO_FSEQ'}{$fseq}{'END_TRACK'};
  } else {
    $self->error("fseq $fseq not found in ns metadata");
    return undef;
  }
}

sub get_start_pos_track_by_fseq {
  my ($self,$fseq)=@_;

  if ($fseq == 0) {return 0}; # special case for modelling BOT

  if (exists ($self->{'INFO_FSEQ'}{$fseq})) {
    return $self->{'INFO_FSEQ'}{$fseq}{'START_POS_TRACK'};
  } else {
    $self->error("fseq $fseq not found in ns metadata");
    return undef;
  }
}

sub get_end_pos_track_by_fseq {
  my ($self,$fseq)=@_;

  if ($fseq == 0) {return 0}; # special case for modelling BOT

  if (exists ($self->{'INFO_FSEQ'}{$fseq})) {
    return $self->{'INFO_FSEQ'}{$fseq}{'END_POS_TRACK'};
  } else {
    $self->error("fseq $fseq not found in ns metadata");
    return undef;
  }
}

# get the direction of the track where the first block of the segment of fseq is found.
# 0: forward, 1: backward
sub track_direction_start {
  my ($self,$fseq)=@_;

  if ($fseq == 0) {return 0}; # special case for modelling BOT

  return $self->get_start_track_by_fseq($fseq) %2;
}

# get the direction of the track where the last block of the segment of fseq is found.
# 0: forward, 1: backward
sub track_direction_end {
  my ($self,$fseq)=@_;

  if ($fseq == 0) {return 0}; # special case for modelling BOT

  return $self->get_end_track_by_fseq($fseq) %2;
}



# calculate the physical distance from the end of the segment fseq1 to the starting of the segment fseq2.
# takes into account opposite numbering for two fseqs on non-equal direction tracks.
# (does not take into account difference in tracks)
# returns -1 if the two segments are adjacent (e.g. one immediately after the other in the same track in the reading direction)
#
sub physical_distance_pos {
  my ($self,$fseq1,$fseq2) = @_;
  if ($self->track_direction_end($fseq1) == $self->track_direction_start($fseq2)) {
    # same direction
    if ($fseq2 - $fseq1 == 1) {
      # special case, it's the next file, so no positioning needed
      # this is handled separately here as LPOS resolution isn't at the block level and thus LPOS distance may be the same for several neighboring segments, but only one is the "real" next segment
      return -1;
    } else {
      return abs($self->get_end_pos_track_by_fseq($fseq1) - $self->get_start_pos_track_by_fseq($fseq2));
    }
  } else {
    # opposite direction
    return abs($self->{'POSPERTRACK'} - $self->get_end_pos_track_by_fseq($fseq1) - $self->get_start_pos_track_by_fseq($fseq2));
  }
}


# check if two segments fseq1, fseq2 do physically overlap in the track direction requiring the drive to step back.
# the third parameter (margin) specifies the margin (in terms of position units) to be applied to both fseqs
# eg. is there a physical overlap in the ranges fseq1[start, end+margin] and fseq2[start-margin, end]?
# to be useful, tracks should be in the same direction. Returns 0 (no overlap) if tracks are in different directions.
sub have_overlap {
  my ($self, $fseq1, $fseq2,$margin) = @_;

  if ($self->track_direction_end($fseq1) == $self->track_direction_start($fseq2)) {
    # same direction
    if ($self->get_end_track_by_fseq($fseq1) == $self->get_start_track_by_fseq($fseq2)) {
      return 0; # cannot overlap if on the same track :-)
    }
    # same direction, but not same track -> overlap possible
    return ((($self->get_end_pos_track_by_fseq($fseq1) + $margin >= $self->get_start_pos_track_by_fseq($fseq2) - $margin)) &&
	    (($self->get_start_pos_track_by_fseq($fseq1) - $margin <= $self->get_end_pos_track_by_fseq($fseq2) + $margin)))
  } else {
    # different direction
    return 0;
  }
}




# compute the cost of moving from fseq1 to fseq2 in terms of seconds.
sub position_cost {
  my ($self, $fseq1, $fseq2) = @_;

  my $phys_distance = $self->physical_distance_pos($fseq1,$fseq2);

  return -1 if ($phys_distance == -1); # obvious case

  #
  # parameters below calculated using multi-Linear Regression analysis of ~380K file positions on LTO-7M
  # these are unconfirmed for other media types (in particular LTO-8) but according to IBM, should be very similar if not identical
  #

  my $penalty = 4.357; # changing fseq to non-contiguous one base overhead

  # is it the same track?
  if ($self->get_end_track_by_fseq($fseq1) != $self->get_start_track_by_fseq($fseq2)) {
    # no, different track, head needs to change track
    $penalty += 6.714; # changing track has an additional overhead
    # are the tracks on the same band?
    if (int($self->get_end_track_by_fseq($fseq1) / ($self->{'TOTALPHYSTRACKS'} / $self->{'TOTALBANDS'})) !=
	int($self->get_start_track_by_fseq($fseq2) / ($self->{'TOTALPHYSTRACKS'} / $self->{'TOTALBANDS'}))) {
      # different band
      $penalty += 3.23; # changing band has an additional overhead
    }
  }
  # are both tracks in the same direction ?
  if ($self->track_direction_end($fseq1) == $self->track_direction_start($fseq2)) {
    # yes, they are in the same direction
    # is the starting of fseq2 in the motion sense after the end of fseq1, or does the drive have to step back?
    if ($self->get_end_pos_track_by_fseq($fseq1) > $self->get_start_pos_track_by_fseq($fseq2)) {
      # begin of fseq2 is before end of fseq1 in the motion sense which therefore requires stopping, rewinding, stopping and changing direction
      $penalty += 11.37; # rewinding has an additional overhead
    }
  } else {
    # no, both tracks are in different direction, head needs to stop and start in opposite direction
    $penalty += 5.363; # direction change has an additional overhead
  }
  return ($self->physical_distance_pos($fseq1,$fseq2) * 0.0005655 + $penalty);
}


sub fseq_info {
  my ($self,$fseq) =@_;
  return ("fseq " . $fseq . " start blockID: ". $self->{'INFO_FSEQ'}{$fseq}{'BLOCKID'} . " start track: " . $self->{'INFO_FSEQ'}{$fseq}{'START_TRACK'} . " end track: " . $self->{'INFO_FSEQ'}{$fseq}{'END_TRACK'} .
		 " start position (wrt track): " . $self->{'INFO_FSEQ'}{$fseq}{'START_POS_TRACK'} .
		 " end position (wrt track): " . $self->{'INFO_FSEQ'}{$fseq}{'END_POS_TRACK'} .
		 " dist-BOT (absolute position): " . $self->physical_distance_pos(0,$fseq) .
		 " dist-BOT (%): " . $self->physical_distance_pos(0,$fseq) / $self->{'POSPERTRACK'} * 100
		);
}

#
# receives a list of fseqs to retrieve and returns them in the optimal order according to the "linear" algorithm.
#
sub fseq_reorder_linear {
  my ($self,@fseqs) = @_;
  # trivial: reorder in numerical order
  return [sort {$a <=> $b} @fseqs];
}

#
# receives a list of fseqs to retrieve and returns them in the optimal order according to the "random" algorithm.
#
sub fseq_reorder_random {
  my ($self,@fseqs) = @_;
  # trivial: reorder the parameters randomly
  return [shuffle(@fseqs)]; # from List::Util
}

#
# receives a list of fseqs to retrieve and returns them in the optimal order according to the "scan" algorithm.
#
sub fseq_reorder_scan {
  my ($self,@fseqs) = @_;
  my $fseq;
  my @forth=(); my @back=(); # two lists: fseqs to be read in the forward and in the backward direction
  foreach $fseq (@fseqs) {
    if ($self->track_direction_start($fseq) == 0) {
      push (@forth,$fseq);
    } else {
      push (@back,$fseq);
    }
  }
  @forth = sort {$self->get_start_pos_track_by_fseq($a) <=> $self->get_start_pos_track_by_fseq($b)} @forth;
  @back =  sort {$self->get_start_pos_track_by_fseq($a) <=> $self->get_start_pos_track_by_fseq($b)} @back;

  foreach $fseq (@forth,@back) {
    foreach my $pivot (@forth,@back) {
      if ($pivot != $fseq && $self->have_overlap($fseq,$pivot,0)) {
	$self->verbose("warning: physical overlap between the following fseqs: $fseq and $pivot");
	$self->debug(1,"overlap 1: " . $self->fseq_info($fseq));
	$self->debug(1,"overlap 2: " . $self->fseq_info($pivot));
      }
    }
  }

  return [@forth,@back];
}


#
# receives a list of fseqs to retrieve and returns them in the optimal order according to the "scan2" algorithm.
# Essentially, consists of splitting up scan into two forth-and-back passes, moving overlapping segments into the
# second pass (in each direction), and thus avoid rewinds for repositioning.
# The second pass is merged back if the number of elements is inferior to a given threshold, in order to avoid useless tape traversals.
#
# This algorithm may be further refined and adsorb the "scan" one - the number of passes might be adapted as a function of the total
# segments to retrieve and thus to seek for; each iteration checks whether there are still overlaps from the previous pass up to a
# defined maximum threshold. Final leftovers are then evenly redistributed across all passes.
#
sub fseq_reorder_scan2 {
  my ($self,@fseqs) = @_;
  my $fseq;
  my (@forth1,@forth2,@back1,@back2);

  my %overlap=();

  foreach $fseq(@fseqs) {
    foreach my $pivot (@fseqs) {
      if ($pivot != $fseq && $self->have_overlap($fseq,$pivot,0)) {
	# mark as overlapping
	$self->verbose("physical overlap between the following fseqs: $fseq and $pivot");
	$self->debug(1,"overlap 1: " . $self->fseq_info($fseq));
	$self->debug(1,"overlap 2: " . $self->fseq_info($pivot));
	$overlap{$pivot > $fseq ? $fseq : $pivot} = 1; # just mark the first fseq in the overlap hash (avoid marking both)
      }
    }
  }

  foreach $fseq (@fseqs) {
    if ($self->track_direction_start($fseq) == 0) {
      if (exists $overlap{$fseq}) {
	push (@forth2,$fseq)
      } else {
	push (@forth1,$fseq)
      }
    } else {
      if (exists $overlap{$fseq}) {
	push (@back2,$fseq);
      } else {
	push (@back1,$fseq);
      }
    }
  }

  # if there are less than 10 elements in either of the second scan list, merge them back as it's not worth it.
  if ((scalar @forth2) < 10) {
    push(@forth1,@forth2); @forth2=();
  }
  if ((scalar @back2) < 10) {
    push(@back1,@back2); @back2=();
  }


  @forth1 = sort {$self->get_start_pos_track_by_fseq($a) <=> $self->get_start_pos_track_by_fseq($b)} @forth1;
  @forth2 = sort {$self->get_start_pos_track_by_fseq($a) <=> $self->get_start_pos_track_by_fseq($b)} @forth2;
  @back1 = sort {$self->get_start_pos_track_by_fseq($a) <=> $self->get_start_pos_track_by_fseq($b)} @back1;
  @back2 = sort {$self->get_start_pos_track_by_fseq($a) <=> $self->get_start_pos_track_by_fseq($b)} @back2;

  return [@forth1,@back1,@forth2,@back2];
}



#
# receives a list of fseqs to retrieve and returns them in the optimal order according to the "MPscan" algorithm.
#
#sub fseq_reorder_mpscan {
#  my ($self,@fseqs) = @_;
#
#  (....) return [@fseqs_reordered];
#}

#
# receives a list of fseqs to retrieve and returns them in the optimal order according to the "SLTF" (shortest locate time first aka nearest neighbor) algorithm.
# note: always starts with BOT (fseq 0).
#
sub fseq_reorder_sltf {
  my ($self, @fseqs) = @_;

  my @visited=();
  my $pivot = 0;
  my $count = 0;
  while ($count < scalar(@fseqs)) {
    $self->debug(1,"pivot fseq: ",$pivot);
    my $nearestcost = undef;
    my $nearestel = undef;
    foreach my $i (@fseqs) {
      next if (grep {$_ == $i} @visited);
      my $cost=$self->position_cost($pivot,$i);
      $self->debug(1, "----considering fseq: $i - cost: $cost");
      if (!defined $nearestcost || $cost < $nearestcost) {
	$nearestcost = $cost;
	$nearestel = $i;
      }
    }
    $self->verbose("-- reordering: nearest to fseq $pivot is fseq $nearestel with cost $nearestcost");
    push (@visited,$nearestel);
    $pivot = $nearestel;
    $count++;
  }
  return [@visited];
}



sub _initialize {
  my ($self,$vid)=@_;

  unless (defined $vid) {
    throw_error('bad initialization: VID missing');
    return undef;
  }
  $self->{'VID'}=$vid;
  $self->{'INFO_FNAM'}=undef;
  $self->{'INFO_FSEQ'}=undef;
  $self->{'TOTFILES'}=0;
  $self->{'TOTSIZE'}=0;
  return $self;
}



#############################################################
# tape-verify main program
#############################################################

package main;

use strict;
use LC::Exception qw (SUCCESS throw_error);
use LC::File qw(file_contents);
use vars qw($this_app %SIG);
use Date::Parse;

$EC=LC::Exception::Context->new->will_store_all;


my $vid=undef;
my $total_errors=0;
my $total_warnings=0;
my $total_size=0;

#------------------------------------------------------------
# Functions in the main program
#------------------------------------------------------------

sub signal_handler {
  my $signal=shift;
  # ignore further signals!!
  $SIG{'INT'} ='IGNORE';
  $SIG{'TERM'}='IGNORE';
  $SIG{'QUIT'}='IGNORE';
  $SIG{'USR2'}='IGNORE';
  $SIG{'HUP'}='IGNORE';
  $this_app->warn('signal handler: received signal: '.$signal);
  $this_app->error('tape-verify exiting after signal hit.');
  exit(-1);
}


sub finish {
  unless ($total_errors) {
    if (!$total_warnings) {
      $this_app->OK('tape-verify for VID '.$vid.' terminated successfully.');
    } else {
      $this_app->warn('tape-verify for VID '.$vid.' terminated with '.$total_warnings.' warnings.');
    }
    exit(0);
  } else {
    $this_app->error('tape-verify for VID '.$vid.' terminated with '.$total_errors.' errors and '.$total_warnings.' warnings.');
    exit(-1);
  }
}



#------------------------------------------------------------
# main loop
#------------------------------------------------------------


#
# Handle signals properly
#
$SIG{'INT'} =\&signal_handler;
$SIG{'TERM'}=\&signal_handler;
$SIG{'QUIT'}=\&signal_handler;
$SIG{'USR2'}=\&signal_handler;
$SIG{'HUP'}='IGNORE';

#
# initialize the tape-verify application
#
unless ($this_app = tape_verify_vid->new($0,@ARGV)) {
  throw_error("cannot start application");
}


#
# process command line options before proceeding.
#


unless (scalar @ARGV) {
  $this_app->report($this_app->{'USAGE'});
  exit(-1);
}

unless (@ARGV >1 || $this_app->option("all") || $this_app->option("first") || $this_app->option("last") ||
	$this_app->option("random")) {
  $this_app->error("Please specify --all, or \n".
		   "[--first] [--last] [--random] [file or fseq] [file or fseq] ..");
  $this_app->report($this_app->{'USAGE'});
  exit (-1);
}
if ($this_app->option("all") && ( $this_app->option("first") || $this_app->option("last") ||
				  $this_app->option("random") || @ARGV > 1 )) {
  $this_app->error("the --all option is incompatible with the --first, --last, --random options, or with providing files via the command line");
  $this_app->report($this_app->{'USAGE'});
  exit (-1);
}


unless ($this_app->option("mdcheck") =~ m%^(warn|error)$% ) {
  $this_app->error ("mdcheck must be either 'warn' or 'error'");
  $this_app->report($this_app->{'USAGE'});
  exit(-1);
}


$vid= shift (@ARGV);

#
# start using log file
#
my $logfile=$this_app->option("logdir").'/tape-verify-'.$vid.'.log';
my $objlog=CAF::Log->new($logfile,'at');
unless (defined $objlog) {
  $this_app->error('cannot open log file: '.$logfile);
  exit(-1);
}
$this_app->set_report_logfile($objlog);



$this_app->log('-----------------------------------------------------');
$this_app->info('tape-verify version '. $this_app->version().' started by '.
	    $this_app->username() .' at: '.scalar(localtime).' on '.$this_app->hostname());


my $nsinfo=NServerInfo->new($vid);

#
# get nslisttape information for $vid
#

$this_app->info('obtaining name server information for VID '.$vid.' ...');

my $nscheck = $nsinfo->load_ns_info();
if (!defined $nscheck) {
  $this_app->error("cannot obtain name server information for VID $vid");
  $total_errors++;
  &finish();
} else {
  $total_errors += @{$nscheck}[0];
  $total_warnings += @{$nscheck}[1];
}

# do we have anything on tape?
if (0 == scalar(@{$nsinfo->get_list_fseq()})) {
  $this_app->info("no files found on name server for VID ".$vid.", terminating..");
  &finish();
}


#
# get the list of files to process
#

my @fseqs=();
my ($complete,$first,$last)=(0,0,0);

if ($this_app->option('all') || $this_app->option('fulltape')){
  #  check requested for all files on tape
  #   meaning:
  #            'all'      -> all fseqs defined in the name server
  #            'fulltape' -> all fseqs, including deleted ones. Caveat - does only check up to the last segment known to the ns
  @fseqs=@{$nsinfo->get_list_fseq()};

} else {

  if ($this_app->option('first')) {
    push (@fseqs,@{$nsinfo->get_first_fseq($this_app->option('first'))});
  }
  if ($this_app->option('last')) {
    push (@fseqs,@{$nsinfo->get_last_fseq($this_app->option('last'))});
  }
  if ($this_app->option('random')) {
    push (@fseqs,@{$nsinfo->get_random_fseq($this_app->option('random'))});
  }


  if (@ARGV) {
    # provided files and/or fseqs as command line arguments
    my $object;
    foreach $object (@ARGV) {
      if ($object =~ m%^/castor/.+%) {
	# castor file
	my $fseq = $nsinfo->get_fseq_by_fname($object);
	unless (defined $fseq) {
	  $this_app->error("fseq not found in VID $vid for file $object");
	  $total_errors++;
	  &finish();
	} else {
	  push(@fseqs,$fseq);
	}
      } else {
	# assume fseq
	my $fname = $nsinfo->get_fname_by_fseq($object);
	unless (defined $fname) {
	  $this_app->error("the following fseq is not found on VID $vid: $object");
	  $total_errors++;
	  &finish();
	} else {
	  push(@fseqs,$object);
	}
      }
    }
  }
  # remove potential duplicates, as multiple options can lead to fseqs appearing more than once
  my %seen = ();
  @fseqs = grep { ! $seen{ $_ }++ } @fseqs;
}


#
# Order the fseqs according to selected tape positioning algorithm (default is linear)
#

$this_app->verbose("list of fseqs to be checked before reordering: " . join(",",@fseqs));

my $rao = 0; # use RAO?

if (lc($this_app->option('posalgo')) eq "linear") {
  # LINEAR algorithm
  $this_app->info("verifying using linear fseq reordering algorithm");
  @fseqs = @{$nsinfo->fseq_reorder_linear(@fseqs)};
} elsif (lc($this_app->option('posalgo')) eq "scan") {
  # SCAN algorithm
  $this_app->info("verifying using single-scan fseq reordering algorithm");
  @fseqs = @{$nsinfo->fseq_reorder_scan(@fseqs)};
} elsif (lc($this_app->option('posalgo')) eq "scan2") {
  # SCAN algorithm
  $this_app->info("verifying using double-scan fseq reordering algorithm");
  @fseqs = @{$nsinfo->fseq_reorder_scan2(@fseqs)};
} elsif (lc($this_app->option('posalgo')) eq "sltf") {
  # SLTF algorithm
  $this_app->info("verifying using SLTF fseq reordering algorithm");
  @fseqs = @{$nsinfo->fseq_reorder_sltf(@fseqs)};
} elsif (lc($this_app->option('posalgo')) eq "random") {
  # RANDOM algorithm
  $this_app->info("verifying using random fseq reordering algorithm");
  @fseqs = @{$nsinfo->fseq_reorder_random(@fseqs)};
} elsif (lc($this_app->option('posalgo')) eq "rao") {
  # RAO
  $this_app->info("verifying using drive-assisted Recommended Access Order (RAO) algorithm");
  $rao = 1;
  if ($vid =~ m%^L%) {
    $this_app->warn("RAO not supported on LTO, falling back to SLTF");
    @fseqs = @{$nsinfo->fseq_reorder_sltf(@fseqs)};
    $rao = 0;
  }
  if ($this_app->option("positioning") ne "block") {
    $this_app->warn("RAO only available with block positioning, falling back to SLTF");
    @fseqs = @{$nsinfo->fseq_reorder_sltf(@fseqs)};
    $rao = 0;
  }
} else {
  $this_app->warn("not supported positioning algorithm: ".$this_app->option('posalgo').", falling back to SLTF");
  @fseqs = @{$nsinfo->fseq_reorder_sltf(@fseqs)};
}

unless ($rao == 1) {
  $this_app->verbose("list of fseqs to be checked after reordering: " . join(",",@fseqs));
}

my $i=1;
foreach my $fseq (@fseqs) {
  $this_app->verbose("reordered: VID " . $vid . " " . $this_app->option('posalgo') . " # " . $i . " : " . $nsinfo->fseq_info($fseq));
  $i++;
}



#
# check what kind of metadata check is required
#
if (($this_app->option('metadata') eq "full") || ($this_app->option('metadata') eq 'only')) {
  $this_app->info("verifying file metadata for ".scalar(@fseqs)." files, please wait....");

  $nscheck = $nsinfo->check_file_metadata(@fseqs);
  if (!defined $nscheck) {
    $this_app->error("cannot obtain name server information for VID $vid");
    $total_errors++;
    &finish();
  } else {
    $total_errors += @{$nscheck}[0];
    $total_warnings += @{$nscheck}[1];
  }
  if ($this_app->option('metadata') eq 'only') {
    # all done
    &finish();
  }
}


# calculate total size of files to be verified
foreach (@fseqs) {
  $total_size += @{$nsinfo->get_checksum_size_by_fseq($_)}[1];
}


if ($this_app->option('positioning') eq 'fseq') {
  # check for --fulltape option. Only supported for readtp for the time being (readtpblkid doesn't support ranges yet, only explicit segments)
  if ($this_app->option('fulltape')) {
    $complete=1;
    $this_app->info('reading complete tape, including deleted segments');
  } else {
    # check if we are asking for too much volume / too many files compared to the thresholds
    if ($total_size > ($this_app->option('volumethreshold')*1000*1000*1000)) {
      # too much data compared to threshold. switch over to full tape check
      $this_app->info("need to check ".$total_size/(1000*1000*1000)." GB > threshold (".$this_app->option('volumethreshold').
		      " GB), switching over to full tape check");
      $complete=1;
    }
    if (scalar(@fseqs) > $this_app->option('filethreshold')) {
      # Too many files compared to threshold. switch over to full tape check
      $this_app->info("need to check ".scalar(@fseqs)." files > threshold (".$this_app->option('filethreshold').
		      " files), switching over to full tape check");
      $complete=1;
    }
  }
}


if ($complete) {
  if ($this_app->option('fulltape')) {
    $first=1;
  } else {
    ($first)=@{$nsinfo->get_first_fseq(1)};
  }
  ($last)=@{$nsinfo->get_last_fseq(1)};
  $this_app->verbose ("verifying all files; fseq numbers: $first - $last");
} else {
  $this_app->verbose("verifying the following fseq numbers: ".join(",",@fseqs));
}


#
# now, run readtp/readtpblkid with the appropriate parameters, and store output
# (unless --noaction specified)

if ($this_app->option('noaction')) {
  $this_app->info('Dry run, no readtp will be started (--noaction flag set)');
  &finish();
}




# use this hash to check with fseqs have been verified.
my %check_fseq=();
foreach (@fseqs) {
  $check_fseq{$_}=0;
}


my $starttime=time();
my $tape_read_start_time=undef;

#
# retry at max --maxretries times the reading of the tape.
#

my $finished=0;
my $readtp_runs=0;

while (!$finished && $readtp_runs < $this_app->option("maxretries")) {

  my $readttape_executable;
  if ($this_app->option("positioning") ne "block") {
    $readttape_executable = $this_app->option('readtp');
  } else {
    $readttape_executable = $this_app->option('readtpblkid');
  }
  unless (-x $readttape_executable) {
    $this_app->error("cannot find executable: ".$readttape_executable);
    $total_errors++;
    &finish();
  }


  $readtp_runs++;
  my $cmd = $readttape_executable." ".$vid;
  if ($complete) {
    $cmd .= ' '.$first.'-'.$last . ' --nodata';
  } else {
    if ($this_app->option("positioning") eq "fseq") {
      # fseq (readtp) positioning
      $cmd .= ' '.join(",",@fseqs);
      $cmd .= ' --nodata'; # no data transmitted
    } else {
      # blockID (readtpblkid) positioning
      foreach my $fseq (@fseqs) {
	# for readtpblkid, format is as follows:
	# fSeq fileStartBlkId fileSize destFile
	# destFile is /dev/null (file:///dev/null)
	# fileSize is ignored in this context thus setting it to 0
	$cmd .= ' ' . $fseq . ' ' . $nsinfo->get_blockid_by_fseq($fseq) . ' 0 file:///dev/null'
      }
      if ($rao == 1) {
	# use RAO for readtpblkid
	$cmd .= ' -r';
      }
    }
  }
  if ($this_app->option("server")) {
    $cmd .= ' -s '.$this_app->option("server");
  }


  $this_app->info('read tape run '.$readtp_runs.': verifying tape '.$vid.' for '.scalar(@fseqs).' file(s) and '.sprintf("%.2f",$total_size/(1000*1000)).
		  ' MB, please be patient...');
  $this_app->verbose('invoking read tape: '.$cmd);

  my ($err,$tpout);
  my $execute_status = LC::Process::execute([ $cmd ],
					    timeout => $this_app->option("tptimeout"),
					    stdout => \$tpout,
					    stderr => \$err
					   );
  my $readttape_status= $?;
  if (!defined $execute_status) {
    # couldn't even run readtp
    if ($EC->error) {
      $this_app->error($EC->error->format_short);
      $EC->ignore_error();
    }
    $this_app->error($tpout) if ($tpout);
    $this_app->error($err) if ($err);
    $this_app->error("failed to run $cmd, aborting...");
    $total_errors++;
    &finish();
  }
  if ($err) {
    $this_app->warn("read tape returned STDERR output: ".$err);
    $total_warnings++;
  }
  $this_app->debug(1,"read tape returned:");
  $this_app->debug(1,$tpout);

  #
  # now analyse the produced output, checking
  # - all fseq's are there
  # - all fseq's are reporting a matching size and checksum
  # - if not, dump out problematic information and problem type

  my $line;
  my $last_recalled_fseq=0; # keep a reference to the last succesfully recalled fseq
  my ($error_found,$retriable_error_found,$skipover_error_found,$error_found_on_fseq)=(0,0,undef);

  # if readtp execution returned != 0, it's already an error, to be checked if recoverable.
  if ($readttape_status != 0) {$error_found = 1};

  foreach $line (split("\n",$err."\n".$tpout)) {
    #
    # parse output. This is currently ugly as the readtp/readtpblkid output
    # isn't designed for script processing, but is easy to change
    # once readtp gets a --script-output option.
    #
    if ($line =~ m%(E|e)rror%) {
      # report any lines containing error from readtp
      $this_app->info('readtp: *** '.$line);
    }
    if ($line =~ m%^(\S+\s\S+\s\S+)\sSelected tape server is (\S+)$%) {
      # tape server identified, report it
      $this_app->info("tape server: ",$2);
      # record time as start time for reading from tape
      unless (defined $tape_read_start_time) {
	$tape_read_start_time=str2time($1);
      }
    } elsif ($line =~ m/^Error message     = "Failed ST read in DriveGeneric::readBlock Errno=5: Input\/output error"/ ||
	     $line =~ m/^Error message     = "Failed ST ioctl (MTFSF) in DriveGeneric::spaceFileMarksForward Errno=5: Input\/output error"/ ||
         $line =~ m/Specified vol. req. not found/ ||
         $line =~ m/^Error message     = "An exception was caught trying to call reportRecallResults"/ ||
         $line =~ m/^Error message     = "RecallReportPacker::EndofSession has been reported  but an error happened somewhere in the process"/ ||
         $line =~ m/Ping VDQM server for volume request with ID/ ||
	 $line =~ m/Unable to receive header/ ||
	 $line =~ m/Failed call to vmgr_querytape/
         ) {
      # error found, retriable
      $error_found=1;
      $retriable_error_found=1;
    } elsif ($line =~ m/^Error code string = "Bad label structure"/) {
      # error found, non-retriable, can be skipped over
      $error_found=1;
      $skipover_error_found=1;
    } elsif ($line =~ m/^Incomplete transfer: fileTransactionId=\S+ tapeFseq=(\S+)/) {
      # error found -
      # provides the first failed fseq.
      $error_found=1;
      $error_found_on_fseq=$1;
      $this_app->info("error found in fseq $error_found_on_fseq, readtp says: ".$line);
      last;
    } elsif ( $line =~ m%^\S+\s\S+\s\S+\sRecalled\s\S+\sfseq=(\S+)\ssize=(\S+)\s\S+\schecksum=(\S+)$% ||
	      $line =~ m%^\S+\s\S+\s\S+\sRecalled\sfseq=(\S+),startBlkId=\S+,fileSize=(\S+),\S+\s\S+\s+checksum=(\S+)$% ) {
      # readtp format:      Aug 27 17:15:19 Recalled "localhost:/dev/null" fseq=1 size=4579746772 checksumType="adler32" checksum=0x8ceea67e
      # readtpblkid format: Aug 27 17:27:43 Recalled fseq=1,startBlkId=0,fileSize=0,destDiskFile=file:///dev/null checksumType="adler32" checksum=0x8ceea67e
        my ($fseq,$size,$checksum)=($1,$2,$3);
        $last_recalled_fseq=$fseq;
        $checksum = substr($checksum, 2); # strip off the leading 0x
        if (! exists $check_fseq{$fseq}) {
   	      # this fseq does not exist in the list of fseqs to be checked.
	      # if we are running in $complete==1 mode, then this is OK. Otherwise, there is another problem
	      if (!$complete) {
	        $this_app->error("fseq $fseq found but not appearing in name server information, consistency problem?");
	        $total_errors++;
	      } else {
	        $this_app->verbose("skipping over fseq $fseq not found in name server - OK as running in full mode");
	        next;
	      }
        }
        $check_fseq{$fseq}=1;
        # compare it with stored information
        my ($seg_chksum,$seg_size)=@{$nsinfo->get_checksum_size_by_fseq($fseq)};
        if ($size ne $seg_size && $this_app->option("positioning") eq "fseq") {
	  # size is not really checked by readtpblkid - it just echoes whatever is provided as input - this is clearly a bug which isn't going to be fixed anytime soon..
	  $this_app->error("size mismatch for fseq $fseq: expected (nameserver): $seg_size, real: $size; filename: ".$nsinfo->get_fname_by_fseq($fseq));
	  $total_errors++;
	}
        if (defined $seg_chksum && $checksum ne $seg_chksum) {
	  $this_app->error("checksum mismatch for fseq $fseq: expected (nameserver): $seg_chksum, real: $checksum ; filename: ".$nsinfo->get_fname_by_fseq($fseq));
	  $total_errors++;
        }
        if (!defined $seg_chksum) {
	  $this_app->warn("no name server checksum available for fseq $fseq, real: $checksum; filename: ".$nsinfo->get_fname_by_fseq($fseq));
	  $total_warnings++;
        }
     } else {
      $this_app->debug(1,'skipping over line: '.$line);
    }
  }

  if ($error_found) {
    if ($retriable_error_found || $skipover_error_found) {
      # do we have an error which can be either retried or skipped over
      if ($retriable_error_found) {
	# start over at the fseq where the error was found.
	if (! $error_found_on_fseq) {
	  # we didn't get where the failure was, so try again after the last succesfully read segment on
	  $error_found_on_fseq=$last_recalled_fseq+1;
	}
	@fseqs = grep {$_ >= $error_found_on_fseq} @fseqs;
	if ($complete) {
	  $first=$fseqs[0];
	  $first = $last unless (defined $first); # in case we are at the last fseq
	}
	$this_app->info("readttape failed with a recoverable error, trying again as from fseq $error_found_on_fseq");
      } elsif ($skipover_error_found) {
	# start over at the next fseq following where the error was found.
	@fseqs = grep {$_ > $error_found_on_fseq} @fseqs;
	if ($complete) {
	  $first=$fseqs[0];
	  $first = $last unless (defined $first); # in case we are at the last fseq
	}
	$this_app->info("readtp failed with an error to be skipped over on fseq $error_found_on_fseq, trying again as from fseq". $fseqs[0]);
      }
      if ((! $complete && ! scalar @fseqs) || ($complete && $first > $last)) {
	last; # we hit the end of the fseqs to be verified, quit the loop
      } else {
	$this_app->info("waiting 60 seconds for the next read tape run...");
	sleep(60);
	next; # next readtp run
      }
    } else {
      $total_errors++;
      $this_app->error("read tape failed with a non-recoverable error");
      $this_app->report("complete output from read tape:");
      $this_app->report($tpout);
      last;
    }
  } else {
    # no error found
    $finished=1;
  }
}

if (!$finished && $readtp_runs > $this_app->option("maxretries")) {
  $this_app->error("read tape failures exceeding configured maximum (".$this_app->option("maxretries")."), giving up");
  $total_errors++;
}

foreach (sort {$a <=> $b} (keys %check_fseq)) {
  if ($check_fseq{$_}==0) {
    $this_app->error ("fseq $_ was not retrieved from tape; filename: ".$nsinfo->get_fname_by_fseq($_));
    $total_errors+=1;
  }
}


$this_app->info("tape verification took ".(time()-$starttime)." seconds ");

if (!$total_errors && defined $tape_read_start_time) {
  # report avg read speed if-f no errors (cannot reliably report speed in case of failures)
  $this_app->info("average read speed was ".sprintf("%.2f",
		  ($total_size/((time()-$tape_read_start_time)*1000*1000))). " MB/s (incl. tape mount time)");
}

&finish();


#*#################################################################
